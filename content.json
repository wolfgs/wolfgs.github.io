{"meta":{"title":"wolfgs Blog","subtitle":null,"description":"wolfgs Blog a simle Blog","author":"lgs","url":"http://wolfgs.com"},"pages":[{"title":"about","date":"2016-11-23T04:40:54.000Z","updated":"2016-11-23T04:40:54.427Z","comments":true,"path":"about/index.html","permalink":"http://wolfgs.com/about/index.html","excerpt":"","content":""},{"title":"tags","date":"2016-11-23T04:07:53.000Z","updated":"2016-11-23T04:07:53.231Z","comments":true,"path":"tags/index.html","permalink":"http://wolfgs.com/tags/index.html","excerpt":"","content":""}],"posts":[{"title":"Node服务器端开发第一天","slug":"node-1-day","date":"2016-11-22T02:39:52.000Z","updated":"2016-11-23T05:01:31.000Z","comments":true,"path":"2016/11/21/node-1-day/","link":"","permalink":"http://wolfgs.com/2016/11/21/node-1-day/","excerpt":"Node服务器端开发第一天 Node简介及配置、快速上手、核心特点、模块化","content":"Node服务器端开发第一天 Node简介及配置、快速上手、核心特点、模块化 Node简介 客户端的JavaScript是怎样的 什么是 JavaScript？ 脚本语言 运行在浏览器中 一般用来做客户端页面的交互（Interactive） JavaScript 的运行环境？ 是不是运行在浏览器呢？ 不够严谨 运行在浏览器内核中的 JS 引擎（engine） 浏览器中的 JavaScript 可以做什么？ 操作DOM（对DOM的增删改、注册事件） AJAX/跨域 BOM（页面跳转、历史记录、console.log()、alert()） ECMAScript 浏览器中的 JavaScript 不可以做什么？ 文件操作（文件和文件夹的CRUD） 没有办法操作系统信息 由于运行环境特殊（我们写的代码是在不认识的人的浏览器中运行） 在开发人员能力相同的情况下编程语言的能力取决于什么？ -语言本身？- 语言本身只是提供定义变量，定义函数，定义类型，流程控制，循环结构之类的操作 取决于运行该语言的平台（环境） 对于JS来说，我们常说的JS实际是ES，大部分能力都是由浏览器的执行引擎决定 BOM和DOM可以说是浏览器开放出来的接口 比如：Cordova中提供JS调用摄像头，操作本地文件的API Java既是语言也是平台 Java运行在Java虚拟机（跨操作系统） PHP既是语言也是平台（跨操作系统） C#语言平台：.NET Framework（Windows） C#可以运行在MONO这样的平台 因为有人需要将C#运行在Linux平台，所有出现了MONO JavaScript 只可以运行在浏览器中吗？ 不是 能运行在哪取决于，这个环境有没有特定平台 什么是Node Node 就是 JavaScript 语言在服务器端的运行环境 所谓“运行环境（平台）”有两层意思： 首先，JavaScript 语言通过 Node 在服务器运行，在这个意义上，Node 有点像 JavaScript 虚拟机； 其次，Node 提供大量工具库，使得 JavaScript 语言与操作系统互动（比如读写文件、新建子进程），在这个意义上， Node 又是 JavaScript 的工具库。 为什么是JavaScriptNode的实现结构Node在当下Web开发领域的应用哪些公司在用重点理解 Node是一个JavaScript的运行环境（平台），不是一门语言，也不是JavaScript的框架； Node的实现结构； Node可以用来开发服务端应用程序，Web系统； 基于Node的前端工具集 环境配置安装包的方式安装 安装包下载链接： Mac OSX： darwin Windows： x64 x86 安装操作： 一路Next 更新版本 操作方式： 重新下载最新的安装包； 覆盖安装即可； 问题： 以前版本安装的很多全局的工具包需要重新安装 无法回滚到之前的版本 无法在多个版本之间切换（很多时候我们要使用特定版本） NVM工具的使用 Node Version Manager（Node版本管理工具） 由于以后的开发工作可能会在多个Node版本中测试，而且Node的版本也比较多，所以需要这么款工具来管理 安装操作步骤 下载：nvm-windows 解压到一个全英文路径 编辑解压目录下的settings.txt文件（不存在则新建） root 配置为当前 nvm.exe 所在目录 path 配置为 node 快捷方式所在的目录 arch 配置为当前操作系统的位数（32/64） proxy 不用配置 配置环境变量 可以通过 window+r : sysdm.cpl NVM_HOME = 当前 nvm.exe 所在目录 NVM_SYMLINK = node 快捷方式所在的目录 PATH += %NVM_HOME%;%NVM_SYMLINK%; 打开CMD通过set [name]命令查看环境变量是否配置成功 PowerShell中是通过dir env:[name]命令 NVM使用说明： https://github.com/coreybutler/nvm-windows/ NPM的目录之后使用再配置 配置Python环境 Node中有些第三方的包是以C/C++源码的方式发布的，需要安装后编译确保全局环境中可以使用python命令 环境变量的概念 环境变量就是操作系统提供的系统级别用于存储变量的地方 Windows中环境变量分为系统变量和用户变量 环境变量的变量名是不区分大小写的 特殊值： PATH 变量：只要添加到 PATH 变量中的路径，都可以在任何目录下搜索 Windows下常用的命令行操作 切换当前目录（change directory）：cd 创建目录（make directory）：mkdir 查看当前目录列表（directory）：dir 别名：ls（list） 清空当前控制台：cls 别名：clear 删除文件：del 别名：rm 注意：所有别名必须在新版本的 PowerShell 中使用 快速上手 事件驱动和非阻塞 模块化开发","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://wolfgs.com/tags/node/"},{"name":"Another Tag","slug":"Another-Tag","permalink":"http://wolfgs.com/tags/Another-Tag/"}]},{"title":"我出上联，你答下联","slug":"shang","date":"2016-11-22T02:24:40.000Z","updated":"2016-11-23T02:35:32.000Z","comments":true,"path":"2016/11/21/shang/","link":"","permalink":"http://wolfgs.com/2016/11/21/shang/","excerpt":"","content":"熊猫宝贝今天下班回到家，男票问了我一个很难很难的问题，我百思不得其解，所以来这里求助聪明的你们啦！这是个关于对联的问题。 上联：熊猫的胸毛是熊毛 下联是什么呢？ 小伙伴们，我在评论区等你们哦熊猫宝贝","categories":[],"tags":[{"name":"散文","slug":"散文","permalink":"http://wolfgs.com/tags/散文/"}]},{"title":"html","slug":"html","date":"2016-11-21T20:47:23.000Z","updated":"2016-11-21T07:47:23.000Z","comments":true,"path":"2016/11/21/html/","link":"","permalink":"http://wolfgs.com/2016/11/21/html/","excerpt":"","content":"","categories":[],"tags":[]},{"title":"hexo常用命令笔记","slug":"hexo changyong","date":"2016-11-21T19:24:29.000Z","updated":"2016-11-21T10:03:46.000Z","comments":true,"path":"2016/11/21/hexo changyong/","link":"","permalink":"http://wolfgs.com/2016/11/21/hexo changyong/","excerpt":"hexonpm install hexo -g #安装npm update hexo -g #升级hexo init #初始化","content":"hexonpm install hexo -g #安装npm update hexo -g #升级hexo init #初始化简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate –watch #监视文件变动 完成后部署两个命令的作用是相同的hexo generate –deployhexo deploy –generatehexo deploy -ghexo server -g 草稿hexo publish [layout] &lt; title &gt; 模版hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt; title &gt;hexo new photo “My Gallery”hexo new “Hello World” –lang tw 变量 描述layout 布局title 标题date 文件建立日期title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。模版（Scaffold）hexo new photo “My Gallery” 变量 描述layout 布局title 标题date 文件建立日期设置文章摘要以上是文章摘要 &lt;! – more – &gt; 以下是余下全文写作hexo new page &lt; title&gt;hexo new post &lt; title&gt; 变量 描述:title 标题:year 建立的年份（4 位数）:month 建立的月份（2 位数）:i_month 建立的月份（去掉开头的零）:day 建立的日期（2 位数）:i_day 建立的日期（去掉开头的零）推送到服务器上hexo n #写文章hexo g #生成hexo d #部署 #可与hexo g合并为 hexo d -g","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://wolfgs.com/tags/hexo/"}]},{"title":"hexo常用命令笔记","slug":"hexo node","date":"2016-11-21T19:24:29.000Z","updated":"2016-11-21T06:58:41.000Z","comments":true,"path":"2016/11/21/hexo node/","link":"","permalink":"http://wolfgs.com/2016/11/21/hexo node/","excerpt":"hexonpm install hexo -g #安装npm update hexo -g #升级hexo init #初始化","content":"hexonpm install hexo -g #安装npm update hexo -g #升级hexo init #初始化简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate –watch #监视文件变动 完成后部署两个命令的作用是相同的hexo generate –deployhexo deploy –generatehexo deploy -ghexo server -g 草稿hexo publish [layout] &lt; title &gt; 模版hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt; title &gt;hexo new photo “My Gallery”hexo new “Hello World” –lang tw 变量 描述layout 布局title 标题date 文件建立日期title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。模版（Scaffold）hexo new photo “My Gallery” 变量 描述layout 布局title 标题date 文件建立日期设置文章摘要以上是文章摘要 &lt;! – more – &gt; 以下是余下全文写作hexo new page &lt; title&gt;hexo new post &lt; title&gt; 变量 描述:title 标题:year 建立的年份（4 位数）:month 建立的月份（2 位数）:i_month 建立的月份（去掉开头的零）:day 建立的日期（2 位数）:i_day 建立的日期（去掉开头的零）推送到服务器上hexo n #写文章hexo g #生成hexo d #部署 #可与hexo g合并为 hexo d -g","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://wolfgs.com/tags/hexo/"}]},{"title":"hexo常用命令笔记","slug":"hexo??????","date":"2016-11-21T19:24:29.000Z","updated":"2016-11-21T06:58:41.000Z","comments":true,"path":"2016/11/21/hexo??????/","link":"","permalink":"http://wolfgs.com/2016/11/21/hexo??????/","excerpt":"hexonpm install hexo -g #安装npm update hexo -g #升级hexo init #初始化","content":"hexonpm install hexo -g #安装npm update hexo -g #升级hexo init #初始化简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate –watch #监视文件变动 完成后部署两个命令的作用是相同的hexo generate –deployhexo deploy –generatehexo deploy -ghexo server -g 草稿hexo publish [layout] &lt; title &gt; 模版hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt; title &gt;hexo new photo “My Gallery”hexo new “Hello World” –lang tw 变量 描述layout 布局title 标题date 文件建立日期title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。模版（Scaffold）hexo new photo “My Gallery” 变量 描述layout 布局title 标题date 文件建立日期设置文章摘要以上是文章摘要 &lt;! – more – &gt; 以下是余下全文写作hexo new page &lt; title&gt;hexo new post &lt; title&gt; 变量 描述:title 标题:year 建立的年份（4 位数）:month 建立的月份（2 位数）:i_month 建立的月份（去掉开头的零）:day 建立的日期（2 位数）:i_day 建立的日期（去掉开头的零）推送到服务器上hexo n #写文章hexo g #生成hexo d #部署 #可与hexo g合并为 hexo d -g","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://wolfgs.com/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-11-21T17:42:18.000Z","updated":"2016-11-21T06:47:46.000Z","comments":true,"path":"2016/11/21/hello-world/","link":"","permalink":"http://wolfgs.com/2016/11/21/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://wolfgs.com/tags/nodejs/"}]},{"title":"nodejs 进阶","slug":"nodejs-into","date":"2016-11-17T03:42:18.000Z","updated":"2016-11-23T05:01:36.000Z","comments":true,"path":"2016/11/16/nodejs-into/","link":"","permalink":"http://wolfgs.com/2016/11/16/nodejs-into/","excerpt":"hexo–搭建 前言Hexo是一个很好的博客，个人觉得他的界面干净利落，阅读体验也是很好。初次接触Hexo是在朋友的介绍下才知道的，hexo是需要手动搭建（觉得B格很高），在朋友的帮助下也终于是完成了。 开篇记录一下搭建的过程希望能帮助到浏览到这里的朋友","content":"hexo–搭建 前言Hexo是一个很好的博客，个人觉得他的界面干净利落，阅读体验也是很好。初次接触Hexo是在朋友的介绍下才知道的，hexo是需要手动搭建（觉得B格很高），在朋友的帮助下也终于是完成了。 开篇记录一下搭建的过程希望能帮助到浏览到这里的朋友我的系统为OS X，windows也可以参考。 简介 Hexo是一个开源的静态博客生成器，用node.js开发，作者是台湾大学生tommy351。 思路总结 安装过程中如果出现问题请到最后面查看问题总结，或许能帮助你解决问题。 环境配置 安装Git 安装过Xcode可以直接跳过这步，因为Xcode自带Git Git有很多，Mac和Windows都可以直接到git-scm官网下载安装 安装node.js 奉上Macnode-v4.2.2.pkg安装包。 这两个软件的安装步骤就不多做介绍，一直点下一步就好 安装 安装hexo sudo npminstall-ghexo 初始化 我们可以创建一个新文件夹作为hexo的安装目录，把所有的hexo文件都放里面，主要是为了方便管理。 初始化有两种方式： 直接指定目录 hexo init folderfolder:是指定目录的文件路径。例：/Documents/hexo 进入指定目录(cd /文件夹路径) hexoinit 终端执行命令后显示的结果： [info] Copying data[info] You are almost done! Don’t forgettorunnpm installbeforestart bloggingwithHexo! 安装依赖包 sudo npminstall 生成静态页面 cd 到你的hexo安装目录（工作目录），执行如下命令 hexogenerate简写 hexog 必须到你新建的hexo安装目录下执行，否则不成功 本地启动测试 hexoserver简写 hexo s 到此本地服务已经完成，可以再浏览器中输入http://localhost:4000进行查看。接下来需要把我们创建的静态页面托管到github上，别人才能访问到 部署到Github 注册Github账号 这里就不再赘述，已有Github账号可以跳过此步骤。 新建repository(仓库) 登陆Github账号后，点击右上角的“+”号按钮，选择“New repository” 在Create a new repository界面填写格式如下图所示: 用户名.github.io 填写完成点Create repository创建完成 生成SSH Keys： 我们如何让本地git项目与远程的github建立联系？这时候就要用到SSH Keys 1、生成SSH Keys 使用ssh-keygen命令生成密钥对 ssh-keygen -t rsa -C”这里是你申请Github账号时的邮箱” 然后系统会要你输入密码：（我们输入的密码会在你提交项目的时候使用） Enter passphrase (emptyforno passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; （终端提示生成的文件路径）找到你生成的密钥找到id_rsa.pub用终端进入编辑，复制密钥。 2、添加你的SSH Key到ssh-agent 添加你的SSH Key到ssh-agent //在后台打开 ssh-agenteval”$(ssh-agent -s)”添加你的SSH Key到ssh-agentssh-add ~/.ssh/id_rsa 添加SSH Key到Github： 1、添加SSH Key 通过命令复制SSH Key内容到系统剪贴板 pbcopy &lt; ~/.ssh/id_rsa.pub 登陆Github,点击右侧用户按钮，选择Settings 点击 Add SSH key 按钮，将复制的密钥粘贴到 Key 栏 2、测试能不能链接成功 测试 ssh-T git@github.com 执行结果 Permanently addedtheRSA host keyforIP address ‘192.30.252.130’tothelistofknown hosts.Are you sure you wanttocontinueconnecting (yes/no)?&lt;输入yes&gt;Hi username! You’ve successfully authenticated,butGitHubdoesnot 现在你已经可以通过SSH链接到Github了 如果有问题，请再配置。参考网站 生成SSH Keys Generating SSH Keys Error: Permission denied (publickey)错误 Error: Permission denied (publickey) 设置你的用户名和密码： Git会根据用户的名字和邮箱来记录提交，GitHub也是用这些信息来做权限的处理。 git config –global user.name”这里是你申请Github账号时的name”git config –global user.email”这里是你申请Github账号时的邮箱” 部署 编辑 _config.yml(在你的工作目录下)，把下面的your_username换成你的github用户名 deploy:type: gitrepo:https://github.com/your_username/your_username.github.io.gitbranch: master 执行部署命令 hexod-ghexogenerate和 hexo deploy 合写 问题： 1、 部署时出现：Error: EACCES, open ‘/Users/Desktop/hexo/public/js/script.js’ 原因：权限问题在部署命令前加sudo 2、 deployer找不到git: ERROR Deployer not found: git 解决方法:npm install hexo-deployer-git –save 3、 { [Error:Cannot find module’./build/Release/DTraceProviderBindings’]code:’MODULE_NOT_FOUND’}{ [Error:Cannot find module’./build/default/DTraceProviderBindings’]code:’MODULE_NOT_FOUND’}{ [Error:Cannot find module’./build/Debug/DTraceProviderBindings’]code:’MODULE_NOT_FOUND’} 解决方法： npminstall hexo –no-optional 4、npm install卡住不动 使用cnpm加速npm(原文地址：https://cnodejs.org/topic/5338c5db7cbade005b023c98) npm–registry=https://registry.npm.taobao.org install koa","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://wolfgs.com/tags/nodejs/"}]},{"title":"辨析 Sass 中的 Map 和 List","slug":"demo","date":"2015-10-21T14:34:12.000Z","updated":"2016-11-21T07:55:59.939Z","comments":true,"path":"2015/10/21/demo/","link":"","permalink":"http://wolfgs.com/2015/10/21/demo/","excerpt":"如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。 自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。 那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 package.json 或者其他同类型的项目配置文件所控制，往往只需一条命令（gem update sass）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。","content":"如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。 自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。 那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 package.json 或者其他同类型的项目配置文件所控制，往往只需一条命令（gem update sass）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。 使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。 测试表格 Variable Description site Sitewide information. page Page specific information and custom variables set in front-matter. config Site configuration theme Theme configuration. Inherits from site configuration. _ (single underscore) Lodash library path Path of current page url Full URL of current page env Environment variables 语法比较 测试标题 在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 min-width、max-width、font-size 和 line-height 四个样式。 Map 语法下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。 1234567891011121314151617181920212223242526$breakpoint-map: ( small: ( min-width: null, max-width: 479px, base-font: 16px, vertical-rhythm: 1.3 ), medium: ( min-width: 480px, max-width: 959px, base-font: 18px, vertical-rhythm: 1.414 ), large: ( min-width: 960px, max-width: 1099px, base-font: 18px, vertical-rhythm: 1.5 ), xlarge: ( min-width: 1100px, max-width: null, base-font: 21px, vertical-rhythm: 1.618 )); 多重列表语法下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 nth() 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。 123456$breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, null, 21px, 1.618)); 遍历比较 测试标题 从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？ 遍历 Map我们可以使用如下的代码遍历 Map： 1@each $label, $map in $breakpoint-map &#123;&#125; 这里的变量 $label 和 $map 会随着对 $breakpoint-map 的遍历被动态地赋值，$label 将会被赋值为 $breakpoint-map 的 Key，而 $map 会被赋值为 $breakpoint-map 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 map-get() 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。 具体的做法就是使用 @each 遍历 Map，然后使用 map-get() 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历： 123456@each $label, $map in $breakpoint-map &#123; $min-width: map-get($map, min-width); $max-width: map-get($map, max-width); $base-font: map-get($map, base-font); $vertical-rhythm: map-get($map, vertical-rhythm);&#125; 遍历多重列表遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 map-get() 函数取特定值，直接遍历一遍即可获得特定值。 因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 map-get()，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符： 12@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;&#125; 慎用多重列表 测试标题 经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。 遗漏键值如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况： 1234567891011121314151617181920$breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, 21px, 1.618));p &#123; @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123; @if $min-width &#123; @include breakpoint( $min-width ) &#123; font-size: $base-font; line-height: $vertical-rhythm; &#125; &#125; @else &#123; font-size: $base-font; line-height: $vertical-rhythm; &#125; &#125;&#125; 当我们尝试运行这段代码时，结果肯定是错误地，因为在 $breakpoint-list 的最后一行，xlarge 被赋值给了 $label，1100px 被赋值给了 $min-width，21px 被赋值给了 $max-width, 1.618 被赋值给了 $base-font，最终导致 $vertical-rhythm 没有被赋值，结果就是 font-size 的属性值是错的，line-height 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。 如果我们使用 Map 来代替这里的多重列表，那么使用 map-get() 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。 查找特定列表在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 map-get() 函数可以快速定位到特定子 Map： 1$medium-map: map-get($maps, medium); 但如果要获取多种列表 medium 列表，麻烦可就大了： 123456789@function get-list($label) &#123; @each $list in $breakpoint-list &#123; @if nth($list, 1) == $label &#123; @return $list; &#125; &#125; @return null;&#125;$medium-list: get-list(medium); 这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 null。这实际上就是手工实现了 map-get() 的逻辑。 缺少原生的 Map 函数Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 map-merge() 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 join() 或 append() 来增加新列表，从而模拟出 map-merge() 的效果。 另一个实用的 Map 函数就是 map-has-key()，对于依赖 map-get() 的自定义函数来说，map-has-key() 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。 总结 Test Title 相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。 虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://wolfgs.com/tags/css/"}]}]}